\section{general introduction}

The map library is used for three different sub-parts of our project. They represent an essential part of the front-end due to their unique ability to make sense of the large amount by abstracting away numerical data and making it implicit by showing it on a map with geometrical objects and their color intensity which can represent information as well.
After some investigation in freely-available and open source libraries we decided to use the good-looking and lightweight PolyMaps tool which is entirely based on Javascript and vector graphics which made interfacing easy such as overlaying simple 2D objects. It was thus very easy to add SVG elements to the map, polygons such as rectangles are supported natively through the GeoJSON standard whereas circles need to be rendered individually. As most other open source mapping services PolyMaps uses the geographical information provided by OpenStreetMap in combination with some useful APIs from CloudMade. 

\section{region selection}
In the first view the user can move around the map and change the zoom level to show different parts of the world. While doing so he can also select geographic regions where he wants to analyze the twitter data from. He can do so simply by dragging a new box on the screen. The coding effort behind this small action is quite big and can be decomposed in several steps. First of all the normal drag and drop actin on the map is to move the navigate around. Whenever the user decided to draw a new region, which is done by clicking on a corresponding button, the focus is removed from the map such that the view is fixed. In the second step the movement of the mouse creates a rectangle on top of the map which size is changed depending on the new position of the this cursor. This rectangle is an svg element which is not integrated with the map, only overlaid. When the user releases the mouse button the size of the rectangle does no longer change, the boundaries of the given object are then translated to geographic data, meaning latitude and longitude, which is done using an API call to the PolyMaps library. Those coordinates in turn are used to create a GeoJSON polygon object which can directly be "sticked" to the map which means that when the user moves the map the created object stays on the corresponding geographical position. To distinguish between those different phases we used different colors to notify the user when the rectangle has been sticked to the map. The described action can be repeated to created several selected regions on the map.

When the user clicks on the button to save the selected regions, all geographical data is communicated to the server by saving them in a hidden form field in form as Json data which is transmitted via a POST request.


\section{tweet density display}

On the server side the selected regions are subdivided in even smaller parts such that the analysis can be more fine-grained. For each subregion the number of tweets is collected and saved, this action is repeated for each one of the two keywords as well as for their intersection.
Whenever the user wants to visualize this data he chooses the "mapresult" tab from the navigation in the UI, a view is presented where each subregion of the original regions has a color opacity relative to the number of tweets that occurred in that region. As described above each subregions is represented as a GeoJSON object an can thus be sticked to the map. Furthermore each keywords has a specific color assigned such that the user can quickly identify which part of the diagram on the map corresponds to which keyword. We used those colors uniformly between the venn diagram, region density and clustering views. We also included checkboxes which allow the user to choose which of the 3 sub-diagrams visualize on top of each other.


\section{clustering display}

As the GeoJSON does not allow circle object, meaning a disk with a radius given in some geographical related format, we had to use pure svg circle objects and calculate their corresponding position depending on the current view on the map. this includes calculating their x, y pixel position on the screen as well as their radius which can change when the users zooms. The clustering algorithm, which runs on the server side, performs several levels of clustering which are passed as a JSON string to the interface. Through a UI slider the user can select the level of clustering he wants to visualize. Similar to the previous view the clustering also used 3 different colors to represent the clusters corresponding to each keyword as well as for their intersection to allow quick visualization of hot-spot areas for specific topics.

\section{conclusion}
One important thing to note is that throughout these different views we always save the users select view-position which is done by recording the geographic center of the current view as well as the zoom level. This information allows us to present the same view to the user when he changes from one step to the other such that he does not need to navigate back to the same spot manually.
Although it was already quite hard to understand the API of PolyMaps, \textcolor{red}{my main personal issue with this part was to debug javascript. As a dynamically typed language, it was hard to figure out which part is not working while re-compiling and re-running the entire project at each step took a lot of time. It was however interesting to investigate in a different programming language, not taught at EPFL, but widely used in practise.}
